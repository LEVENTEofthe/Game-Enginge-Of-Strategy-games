Map:
The games are consisting of Matches, and each Match needs one map. Maps are objects of the *tileMap* class, and are loaded from json files that you make with the built in map drawing tool. 

Each map consist of the following
 - Rows and Columns, a map of the size 2 x 3 Will simply have the values 2 and 3 respectively. 
 - Tileset, an image from which the graphics of the map are loaded. The software only stores the file location of the image in a string, meaning that the removal of the file will result in an error. [ I wonder if there is a more elegant and robust solution without having to store them inside the software. ] Each tile shall be [ we'd like to make it compatible with RPG Maker assets, so I'll just look at those specifications later. ]
 - TileData, [ IDK, this is probly the json stuff. Looking at it, it seems to contain the content of the tiles that will be loaded into the map object ]
 - MapObject, basically the instance of the map you created. It's a two-dimensional array of Tile objects that are capable of being filled with map objects such as actors from the Tile data used. It is created in the class constructor by creating it tile-by-tile and respectily giving them the properties of the from TileData. Since the MapObject and TileData are to share column and row dimensions, it is easily done by refering to the same index.

The graphics of the map are being drawn inside GEOSform.cs file's GEOSform_Paint function.
The logic is the following: By going through each index of the 2-dimensional map, we create a rectangle that uses the tile's col&row position to calculate its screen position, [ then hitbox ]


Tile:
Each map consist of tiles, and each tile consist of the following:
 - Column and Row, contrary of the same fields from the tileMap class, these indicate the location the tile object in question. For example, if the values were (row: 1, col: 2), then it would be the tile just right to the one in the uppermost left corner. The index starts by 1.
 - TilesetIndex, which stores which texture the the tile object holds from the tileset. It is stored in an int [ IDK how you get a texture from a picture using only a number tho ]
 - MapObject, an instance of the class by the same name, basically the thing that is occupying the tile in question.
 - ActorStandsHere, a reference[ ? ] to the actor who is occupying the tile. In case of no actor standing on the 


Actors:

actions/events: Actor objects are able to hold multiple [Events] and execute them to alter the state of the match. These events are stored in the actor's [List<ActionEvent>] ActionSet field which is created along with the actor object.

Events: Each [Event] is an user set line of [EventBlock]s that get executed in the set order upon execution. They are basically complex actions that make use of several small actions to create the desired effect. Since [Event] objects are to be stored and serialized into the actor JSON files, an [Event] object only stores the string ID of each [EventBlock] they implement instead of storing whole bodyies of code of the methods they represent.

[EventBlock]s, at their core, are methods encapsulated into a class, for the Events are made up of pure methods that work together. 
You can think of your [EventBlocks] as a list of mere string IDs existing on [ wherever I'll decide to put em ] and the only thing they know about themselves are their input and output types, but no body of code are assinged to them. When you load up the software or your game program, the class [EventBlockPool] statically assings a method (from either inside the SRPG-library or in the "Game Engin Of strategy-games" project) to the implemented [EventBlock]s. 

[EventBlockPool] is a class that is located within "EventBlocks.cs". It works as a dictionary of EventBlock IDs and EventBlocks. The reason for it being a dictionary compared to a mere list of [EventBlock]s is to cheapen the cost of lookup with its [Get] method. An object of this class lives in your game program's code and on opening, it registers each method you'd like to use in your event as [EventBlock]s, stores them and is able to return any by simply refering to the ID of the [EventBlock] in question. This makes it very easy for the [Event] class to access the functions it'd like to execute.

